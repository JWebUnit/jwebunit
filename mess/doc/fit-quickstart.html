<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
    <title>jWebFit - Quick Start</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <link title="Default" href="css/jwebunit.css" type="text/css" rel="stylesheet">
</head>
<body class="default">
<table cellpadding="4" cellspacing="2" border="0" class="default">
    <tbody>
    <tr>
        <td valign="top" style="width: 100px; white-space: nowrap;"><br></td>
        <td valign="top" ><h1 style="text-align: center;">jWebFit Quick Start</h1></td>
    </tr>
    <tr>
        <td valign="top">
            <a href="index.html">Home</a><br>
            <a href="installation.html">Installation</a><br>
            Quick Start<br>
            <a href="api/index.html">Javadoc</a><br>
            <br>
            <a href="http://sourceforge.net/projects/jwebunit/">Project Page</a><br>
            <a href="http://sourceforge.net/projects/jwebunit/files">Download</a><br>
            <br>
            <a href="http://httpunit.sourceforge.net/">HttpUnit</a><br>
            <a href="http://fit.c2.com">Fit</a><br>
            <br>
        </td>
        <td valign="top">
<!-- Begin Main -->
<p>jWebFit is the clever name for extensions to jWebUnit which allow tests to be written with Ward Cunningham's fit framework
as opposed to java / JUnit.  If you are unfamiliar with fit, give yourself a basic idea of how it works by visiting the
<a href="http://fit.c2.com">fit site</a>.
</p>  
<p>There are basically two ways to approach using fit with jWebUnit: use the fit fixtures provided by
us (primarily the WebFixture class), or write your own fit fixtures that interact with the jWebUnit WebTester class.  You can get
off the ground quickly with the former approach, but the latter approach with custom fixtures allows you much greater control and 
ability to define your own testing syntax.
</p>
The QuickStart covers the following topics:<p>
<table class="default" id="topicsTable">
<tr><td><a href="#webfixture">Basic WebFixture Example</a></td></tr>
<tr><td><a href="#tablefixture">Validating table contents with the TableFixture</a></td></tr>
<tr><td><a href="#optiondisplay">Validating select options with OptionDisplay fixture</a></td></tr>
<tr><td><a href="#customfixture">Writing custom fixtures</a></td></tr>
<tr><td><a href="#running">Running the tests</a></td></tr>
<tr><td><a href="#fitnesse">Integrating with Fitnesse</a></td></tr>
</table>

<a name="webfixture">
<h2>Using WebFixture</h2>
<p>
The key class that adapts jWebUnit to fit is the WebFixture class.  It is a fit action fixture that delegates commands and
checks to an instance of a jWebUnit WebTester.  The following example demonstrates use of WebFixture; see <a href="fit-api.html">the list
of checks and commands</a> for more.
</p>

<table border="1">
<tr><td colspan="4"> net.sourceforge.jwebunit.fit.WebFixture</td></tr>
<tr><td>base url</td><td colspan="3">http://myserver:8080/myapp</td></tr>
<tr><td>begin</td><td colspan="3">info.html</td></tr>
<tr><td>check</td><td>form present</td><td colspan="2">expectedFormName</td></tr>

<tr><td> check   </td><td> form element </td><td> color                      </td><td bgcolor="#cfffcf"> red </td></tr>
<tr><td> enter   </td><td> color        </td><td colspan="2"> pink                       </td></tr>
<tr><td> check   </td><td> form element </td><td> color                      </td><td bgcolor="#cfffcf"> pink </td></tr>

<tr><td> press   </td><td colspan="3"> submit       </td></tr>
<tr><td> check   </td><td> title        </td><td colspan="2" bgcolor="#cfffcf"> Color Page                 </td></tr>
<tr><td> check   </td><td> text present </td><td colspan="2" bgcolor="#cfffcf"> Your chosen color was pink </td></tr>
</table>

<a name="tablefixture">
<h2>Using TableFixture</h2>
<p>
The TableFixture and TableRow classes provides a way to validate the contents of simple data tables.  The rows and columns of the
TableFixture act as the expected contents against the targeted application table, and fit reports the results of the
comparison when the fixture is run.  Missing and surplus rows are reported as well as the results of column comparisons.
</p>

<table border="1">
<tr><td colspan="4">net.sourceforge.jwebunit.fit.PersonalInfoTableFixture</td></tr>
<tr><td>name</td><td>citizenship</td><td>state</td><td>sex</td></tr>
<tr><td bgcolor="#cfffcf">John Doe</td><td bgcolor="#cfffcf">a citizen</td><td bgcolor="#cfffcf">Tennessee</td><td bgcolor="#cfffcf">male</td></tr>
<tr><td bgcolor="#cfffcf">Jane Doe</td><td bgcolor="#cfffcf">a citizen</td><td bgcolor="#cfffcf">Tennessee</td><td bgcolor="#cfffcf">female</td></tr>
<tr><td bgcolor="#cfffcf">Pat Doe</td><td bgcolor="#cfffcf">not a citizen</td><td bgcolor="#cfffcf">North Carolina</td><td bgcolor="#cfffcf">female</td></tr>
</table>
<p>
To perform the above validation, both the TableFixture and TableRow classes were extended to provide both the id of the
table to be validated and the mapping of columns to field names:
</p>
<pre>
public class PersonalInfoTableFixture extends TableFixture {

    protected String getSourceTableSummaryOrId() {
        return "personalInfoTable";
    }

    public Class getTargetClass() {
        return PersonalInfoRow.class;
    }
}
</pre>

<pre>
public class PersonalInfoRow extends TableRow {

    public String name;
    public String citizenship;
    public String state;
    public String sex;

    public PersonalInfoRow(String[] rowCells) {
        super(rowCells);
        this.name = rowCells[0];
        this.citizenship = rowCells[1];
        this.state = rowCells[2];
        this.sex = rowCells[3];
    }
}
</pre>

<a name="optiondisplay">
<h2>Using OptionDisplay</h2>
<p>
The OptionDisplay fixture can be used to validate the contents of an html select list.  Either the
human readable lable or the value or both can be validated:
</p>
<p>
<table border="1">
<tr><td>net.sourceforge.jwebunit.fit.OptionDisplay</td></tr>
<tr><td>state</td></tr>
<tr><td>label</td></tr>
<tr><td bgcolor="#cfffcf">Tennessee</td></tr>
<tr><td bgcolor="#cfffcf">Georgia</td></tr>
</table>
</p>
<p>
<table border="1">
<tr><td colspan="2">net.sourceforge.jwebunit.fit.OptionDisplay</td></tr>
<tr><td colspan="2">state</td></tr>
<tr><td>label</td><td>value</td></tr>
<tr><td bgcolor="#cfffcf">Tennessee</td><td bgcolor="#cfffcf">TN</td></tr>
<tr><td bgcolor="#cfffcf">Georgia</td><td bgcolor="#cfffcf">GA</td></tr>
</table>
</p>
<p>
The second row contains the name of the select list, while the third row indicates what is being validated (label, 
value, or both).  Subsequent rows are the expected options.
</p>


<a name="customfixture">
<h2>Using Custom Fixtures</h2>
One of the core ideas behind fit is to create easily readable tests.  Using the WebFixture can be a little
awkward in this regard.  Writing a custom fixture that extends WebFixture or simply uses a WebTester instance itself can
provide a greater control over syntax, allowing for more understandable tests.

<p>
For an example, consider a web page that collects a comment from a user.  It provides a form for entering
the user's name, email address, selecting their country from a list, and a text field for the comment itself.  After
submitting, the user is taken to a page that thanks them for their comment.  A test using the WebFixture is 
shown below:
</p>

<table border="1">
<tr><td colspan="4">net.sourceforge.jwebunit.fit.WebFixture</td></tr>
<tr><td>base url</td><td colspan="3">http://myserver:8080/myapp</td></tr>
<tr><td>begin</td><td colspan="3">comment.html</td></tr>
<tr><td>enter</td><td>customerName</td><td colspan="2">John Doe</td></tr>
<tr><td>enter</td><td>emailAddress</td><td colspan="2">johndoe@megamail.com</td></tr>
<tr><td>select</td><td>country</td><td colspan="2">USA</td></tr>
<tr><td>enter</td><td>comment</td><td colspan="2">Test Comment</td></tr>
<tr><td>press</td><td colspan="3">submit</td></tr>
<tr><td>press</td><td> form element </td><td> color                      </td><td bgcolor="#cfffcf"> pink </td></tr>

<tr><td> check   </td><td> title        </td><td colspan="2" bgcolor="#cfffcf"> Color Page                 </td></tr>
<tr><td> check   </td><td> text present </td><td colspan="2" bgcolor="#cfffcf"> Your chosen color was pink </td></tr>
</table>


<p>You can also check for the presence of submit buttons on the form and submit with a specific button.</p>

<div class="fittable">
<table border="1">
<tr><td colspan="3">net.sourceforge.jwebunit.fit.WebFixture</td></tr>
<tr><td>base url</td><td colspan="2">http://myserver:8080/myapp</td></tr>
<tr><td>begin   </td><td>info.html</td><td></td></tr>
<tr><td>check</td><td> form present </td><td>expectedFormName</td></tr>
<tr><td>check</td><td> submit button  present </td><td> Add </td></tr>
<tr><td>check</td><td> submit button  present </td><td> Modify </td></tr>
<tr><td>enter</td><td> field1 </td><td>value1</td></tr>
<tr><td>press</td><td>submit</td><td>Modify</td></tr>
</table>
</div>

<p>
For pages with more than one form, jWebUnit will establish which form is being worked with implicitly
from the form elements checked or set.  You can also set the form explicitly by form id or name:
</p>
<div class="fittable">
<table border="1">
<tr><td colspan="2">net.sourceforge.jwebunit.fit.WebFixture</td></tr>
<tr><td>base url</td><td>http://myserver:8080/myapp</td></tr>
<tr><td>begin   </td><td>towForm.html</td></tr>
<tr><td> form </td><td>bottomForm</td></tr>
</table>
</div>

<p>
You can work with non-submit (type='button') buttons as well:
</p>

<div class="fittable">
<table border="1">
<tr><td colspan="2">net.sourceforge.jwebunit.fit.WebFixture</td></tr>
<tr><td>base url</td><td>http://myserver:8080/myapp</td></tr>
<tr><td>begin   </td><td>info.html</td></tr>
<tr><td>check </td><td>button present</td><td>popupButtonId</td></tr>
<tr><td>press </td><td>button</td><td>popupButtonId</td></tr>
<tr><td>check</td><td>window present</td><td>popupWindow</td></tr>
</table>
</div>

<p>
In the above examples, we are working with submit buttons and form elements by their
name.  For form elements, it is possible to work with them by label (string followed
by colon before input element).  Before using this approach, consider that the display
label may change, but the submission name of the element will probably remain static.
</p>
<pre>
    public void testFormSubmission() {
        beginAt("/form.html");
        assertFormElementPresentWithLabel("Credit Card Number");
        setFormElementWithLabel("Credit Card Number", "myNumber");
        submit();
    }
</pre>
<br>
<a name="framesAndWindows">
<h2>Working With Frames and Windows</h2>
You can assert the presence of and navigate to windows by name.  For instance, if clicking on a
button on the root page should open a window, you could test for this and go to the popup window
as follows:
<pre>
    public void testPopupWindow() {
        beginAt("/rootPage.html");
        clickLink("popupLink");
        assertWindowPresent("popupWindow):  //optional - gotoWindow will
                                            //perform this assertion.
        gotoWindow("popupWindow");
        ...
        gotoRootWindow();  //Use this method to return to root window.
    }
</pre>
You can work with frames in a similar manner:
<pre>
    public void testFrame() {
        beginAt("/info.html");
        assertFramePresent("contentFrame"); //optional as window above.
        gotoFrame("contentFrame");
        ...
    }
</pre>
<br>
<a name="validation">
<h2>Validating Page Content</h2>
Once you have navigated to the page you wish to test, you can call the assertions provided by jWebUnit to verify it's correctness.<p>
<pre>
    public void testCorrectness() {
        beginAt("/mainPage");
        assertTitleEquals("Main Page");
        assertLinkPresentWithText("Add Widget");
        clickLinkWithText("Add Widget");
        setFormElement("widgetName", "My Widget");
        submit();
        assertTextPresent("Widget successfully added."):
    }
</pre>
<br>
<a name="tableValidation">
<h2>Validating Table Content</h2>
A number of assertions are provided by jWebUnit to validate the contents of tables on a page.
You can simply check for the presence of text within a table, or check layout of all or a portion
of the table.  HttpUnit is used to purge empty rows and columns from the actual table before comparison,
so you may leave spacer cells and rows out of your check.<p>
The below test validates against this html table (the table id attribute is "ageTable"):<p>
<table border="1" cellpadding="2">
<tr><td>Name</td><td>Age</td></tr>
<tr><td>Jim</td><td>30ish</td></tr>
<tr><td>Wilkes</td><td>20ish</td></tr>
</table>
<pre>
    public void testAgeTable() {
        beginAt("/agePage");
        <i>//check that table is present</i>
        assertTablePresent("ageTable");
        <i>//check that a single string is present somewhere in table</i>
        assertTextInTable("ageTable", "Jim");
        <i>//check that a set of strings are present somewhere in table</i>
        assertTextInTable("ageTable",
                          new String[] {"Jim", "Wilkes"});
        <i>//check composition of table rows/columns</i>
        assertTableEquals("ageTable",
                          new String[][] {{"Name", "Age"},
                                          {"Jim", "30ish"},
                                          {"Wilkes", "20ish"}});
    }
</pre>
If you need to validate non-blank table cells that span more than a single column, a set of classes are provided
which represent expected tables, rows, and cells.<p>
<table border="1" cellpadding="2">
<tr><td colspan="2">Age Table</td></tr>
<tr><td>Name</td><td>Age</td></tr>
<tr><td>Jim</td><td>30ish</td></tr>
<tr><td>Wilkes</td><td>20ish</td></tr>
</table>
<pre>
    public void testAgeTable() {
        beginAt("/agePage");
        ExpectedTable ageTable = new ExpectedTable(new Object[][] {
            {new ExpectedCell("Age Table", 2},
            {"Name", "Age"},
            {"Jim", "30ish"},
            {"Wilkes", "20ish"}
        });
        assertTableEquals("ageTable", expectedAgeTable);
    }
</pre>
<br>
<a name="elementValidation">
<h2>Using Element IDs to Validate Content</h2>
jWebUnit allows you to check for the presence of any html element by its id, or for text in an element.
This can be a useful trick to check for the presence of some logical part of the page.
Even in the case of free floating text, a span element can be used to surround the text
and give it a logical id:<p>
&lt;span id="welcomeMessage"&gt;Welcome, Joe User!&lt;/span&gt;
<pre>
    public void testWelcomeMessage() {
        beginAt("/mainPage");
        <i>//check for presence of welcome message by text</i>
        assertTextPresent("Welcome, Joe User!");
        <i>//check for presence of welcome message by element id</i>
        assertElementPresent("welcomeMessage");
        <i>//check for text within an element</i>
        assertTextInElement("welcomeMessage", "Joe User");
    }
</pre>
<br>
<a name="properties">
<h2>Using Property Files to Validate Content</h2>
Another useful testing trick is to use property files for your expected values rather than hard-coded strings.
This is especially useful if your application uses property files as a source for static text and
messages.  The same files can be used to provide the expected values for the tests.<p>
For convenience, most of the jWebUnit assertions that take strings for the expected have an equivalent assertion that will
take a property file key.  You can use the TestContext to set the bundle to be used as well as the
Locale (default is Locale.getDefault()).
<pre>
    public void setUp() throws Exception {
        getTestContext().setBaseURL("http://myserver:8080/myapp");
        getTestContext().setResourceBundleName("ApplicationResources");
    }

    public void testMainPage() {
        beginAt("/mainPage");
        assertTitleEqualsKey("title.mainPage");
        assertKeyPresent("message.welcome");
        assertKeyInTable("mainPageTable", "header.mainPageTable");
    }
</pre>
There is also a getMessage() method on WebTester and WebTestCase that can be used to access
resource bundle messages directly in your tests.<p>
Whether to check for a given logical chunk of text by hard-coded string, property file lookup, or
by use of an element id is up to you.<br><br>
For more information, consult the <a href="api/index.html">Javadocs</a>.
<br>
<!-- End Main -->
        </td>
    </tr>
    <tr>
        <td valign="top" colspan="3"><hr width="100%" size="2"></td>
    </tr>
    <tr>
        <td valign="top" colspan="2">
      <p><font size="-2"><var:publish>Hosted by: <a
 href="file:///D:/working/jwebunit/site/www.sourceforge.net"><img
 src="http://sourceforge.net/sflogo.php?group_id=61302&amp;type=1" width="88"
 height="31" border="0" alt="SourceForge Logo" naturalsizeflag="0"
 align="top">                 </a></var:publish></font></p>
        </td>
    </tr>
    </tbody>
</table>
</body>
</html>
